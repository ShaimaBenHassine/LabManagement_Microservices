{"ast":null,"code":"import _asyncToGenerator from \"D:/Angular/Lab/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, getGlobal, base64, issuedAtTime, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n  activated: false,\n  tokenObservers: []\n};\nconst DEBUG_STATE = {\n  initialized: false,\n  enabled: false\n};\n\nfunction getState(app) {\n  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\n}\n\nfunction setState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n}\n\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1beta';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n  /**\r\n   * The offset time before token natural expiration to run the refresh.\r\n   * This is currently 5 minutes.\r\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n\n  /**\r\n   * This is the first retrial wait after an error. This is currently\r\n   * 30 seconds.\r\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n\n  /**\r\n   * This is the maximum retrial wait, currently 16 minutes.\r\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\n\nclass Refresher {\n  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n\n  start() {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n\n  stop() {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n\n  isRunning() {\n    return !!this.pending;\n  }\n\n  process(hasSucceeded) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.stop();\n\n      try {\n        _this.pending = new Deferred();\n        yield sleep(_this.getNextRun(hasSucceeded)); // Why do we resolve a promise, then immediate wait for it?\n        // We do it to make the promise chain cancellable.\n        // We can call stop() which rejects the promise before the following line execute, which makes\n        // the code jump to the catch block.\n        // TODO: unit test this\n\n        _this.pending.resolve();\n\n        yield _this.pending.promise;\n        _this.pending = new Deferred();\n        yield _this.operation();\n\n        _this.pending.resolve();\n\n        yield _this.pending.promise;\n\n        _this.process(true).catch(() => {\n          /* we don't care about the result */\n        });\n      } catch (error) {\n        if (_this.retryPolicy(error)) {\n          _this.process(false).catch(() => {\n            /* we don't care about the result */\n          });\n        } else {\n          _this.stop();\n        }\n      }\n    })();\n  }\n\n  getNextRun(hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound; // Return typical wait duration interval after a successful operation.\n\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval; // Double interval for next consecutive error.\n\n      this.nextErrorWaitInterval *= 2; // Make sure next wait interval does not exceed the maximum upper bound.\n\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n\n      return currentErrorWaitInterval;\n    }\n  }\n\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst ERRORS = {\n  [\"already-initialized\"\n  /* ALREADY_INITIALIZED */\n  ]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' + 'different options. To avoid this error, call initializeAppCheck() with the ' + 'same options as when it was originally called. This will return the ' + 'already initialized instance.',\n  [\"use-before-activation\"\n  /* USE_BEFORE_ACTIVATION */\n  ]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' + 'Call initializeAppCheck() before instantiating other Firebase services.',\n  [\"fetch-network-error\"\n  /* FETCH_NETWORK_ERROR */\n  ]: 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.',\n  [\"fetch-parse-error\"\n  /* FETCH_PARSE_ERROR */\n  ]: 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-status-error\"\n  /* FETCH_STATUS_ERROR */\n  ]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [\"storage-open\"\n  /* STORAGE_OPEN */\n  ]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [\"storage-get\"\n  /* STORAGE_GET */\n  ]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [\"storage-set\"\n  /* STORAGE_WRITE */\n  ]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [\"recaptcha-error\"\n  /* RECAPTCHA_ERROR */\n  ]: 'ReCAPTCHA error.'\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nfunction getRecaptcha(isEnterprise = false) {\n  var _a;\n\n  if (isEnterprise) {\n    return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n  }\n\n  return self.grecaptcha;\n}\n\nfunction ensureActivated(app) {\n  if (!getState(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\"\n    /* USE_BEFORE_ACTIVATION */\n    , {\n      appName: app.name\n    });\n  }\n}\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n */\n\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0,\n          v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction exchangeToken(_x, _x2) {\n  return _exchangeToken.apply(this, arguments);\n}\n\nfunction _exchangeToken() {\n  _exchangeToken = _asyncToGenerator(function* ({\n    url,\n    body\n  }, platformLoggerProvider) {\n    const headers = {\n      'Content-Type': 'application/json'\n    }; // If platform logger exists, add the platform info string to the header.\n\n    const platformLogger = platformLoggerProvider.getImmediate({\n      optional: true\n    });\n\n    if (platformLogger) {\n      headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\n    }\n\n    const options = {\n      method: 'POST',\n      body: JSON.stringify(body),\n      headers\n    };\n    let response;\n\n    try {\n      response = yield fetch(url, options);\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-network-error\"\n      /* FETCH_NETWORK_ERROR */\n      , {\n        originalErrorMessage: originalError.message\n      });\n    }\n\n    if (response.status !== 200) {\n      throw ERROR_FACTORY.create(\"fetch-status-error\"\n      /* FETCH_STATUS_ERROR */\n      , {\n        httpStatus: response.status\n      });\n    }\n\n    let responseBody;\n\n    try {\n      // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n      responseBody = yield response.json();\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\"\n      /* FETCH_PARSE_ERROR */\n      , {\n        originalErrorMessage: originalError.message\n      });\n    } // Protobuf duration format.\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n\n\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\"\n      /* FETCH_PARSE_ERROR */\n      , {\n        originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` + `format: ${responseBody.ttl}`\n      });\n    }\n\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\n    const now = Date.now();\n    return {\n      token: responseBody.attestationToken,\n      expireTimeMillis: now + timeToLiveAsNumber,\n      issuedAtTimeMillis: now\n    };\n  });\n  return _exchangeToken.apply(this, arguments);\n}\n\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_token': reCAPTCHAToken\n    }\n  };\n}\n\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_enterprise_token': reCAPTCHAToken\n    }\n  };\n}\n\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\n\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n\n      request.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-open\"\n        /* STORAGE_OPEN */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n\n      request.onupgradeneeded = event => {\n        const db = event.target.result; // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\"\n      /* STORAGE_OPEN */\n      , {\n        originalErrorMessage: e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\n\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\n\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\n\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\n\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\n\nfunction write(_x3, _x4) {\n  return _write.apply(this, arguments);\n}\n\nfunction _write() {\n  _write = _asyncToGenerator(function* (key, value) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put({\n      compositeKey: key,\n      value\n    });\n    return new Promise((resolve, reject) => {\n      request.onsuccess = _event => {\n        resolve();\n      };\n\n      transaction.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-set\"\n        /* STORAGE_WRITE */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _write.apply(this, arguments);\n}\n\nfunction read(_x5) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator(function* (key) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = event => {\n        const result = event.target.result;\n\n        if (result) {\n          resolve(result.value);\n        } else {\n          resolve(undefined);\n        }\n      };\n\n      transaction.onerror = event => {\n        var _a;\n\n        reject(ERROR_FACTORY.create(\"storage-get\"\n        /* STORAGE_GET */\n        , {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _read.apply(this, arguments);\n}\n\nfunction computeKey(app) {\n  return `${app.options.appId}-${app.name}`;\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nconst logger = new Logger('@firebase/app-check');\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\n\nfunction readTokenFromStorage(_x6) {\n  return _readTokenFromStorage.apply(this, arguments);\n}\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\n\n\nfunction _readTokenFromStorage() {\n  _readTokenFromStorage = _asyncToGenerator(function* (app) {\n    if (isIndexedDBAvailable()) {\n      let token = undefined;\n\n      try {\n        token = yield readTokenFromIndexedDB(app);\n      } catch (e) {\n        // swallow the error and return undefined\n        logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n      }\n\n      return token;\n    }\n\n    return undefined;\n  });\n  return _readTokenFromStorage.apply(this, arguments);\n}\n\nfunction writeTokenToStorage(app, token) {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n    });\n  }\n\n  return Promise.resolve();\n}\n\nfunction readOrCreateDebugTokenFromStorage() {\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction _readOrCreateDebugTokenFromStorage() {\n  _readOrCreateDebugTokenFromStorage = _asyncToGenerator(function* () {\n    /**\r\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\r\n     * But it won't happen here, because this function will be called exactly once.\r\n     */\n    let existingDebugToken = undefined;\n\n    try {\n      existingDebugToken = yield readDebugTokenFromIndexedDB();\n    } catch (_e) {// failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n    }\n\n    if (!existingDebugToken) {\n      // create a new debug token\n      const newToken = uuidv4(); // We don't need to block on writing to indexeddb\n      // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\n      // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n      // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n      // You should switch to a different browser that supports indexeddb\n\n      writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n      return newToken;\n    } else {\n      return existingDebugToken;\n    }\n  });\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\n\nfunction isDebugMode() {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\n\nfunction getDebugToken() {\n  return _getDebugToken.apply(this, arguments);\n}\n\nfunction _getDebugToken() {\n  _getDebugToken = _asyncToGenerator(function* () {\n    const state = getDebugState();\n\n    if (state.enabled && state.token) {\n      return state.token.promise;\n    } else {\n      // should not happen!\n      throw Error(`\n            Can't get debug token in production mode.\n        `);\n    }\n  });\n  return _getDebugToken.apply(this, arguments);\n}\n\nfunction initializeDebugMode() {\n  const globals = getGlobal();\n  const debugState = getDebugState(); // Set to true if this function has been called, whether or not\n  // it enabled debug mode.\n\n  debugState.initialized = true;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n\n  debugState.enabled = true;\n  const deferredToken = new Deferred();\n  debugState.token = deferredToken;\n\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\n\n\nconst defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\n\nfunction formatDummyToken(tokenErrorData) {\n  return base64.encodeString(JSON.stringify(tokenErrorData),\n  /* webSafe= */\n  false);\n}\n/**\r\n * This function always resolves.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\n\n\nfunction getToken$2(_x7) {\n  return _getToken$.apply(this, arguments);\n}\n\nfunction _getToken$() {\n  _getToken$ = _asyncToGenerator(function* (appCheck, forceRefresh = false) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const state = getState(app);\n    /**\r\n     * First check if there is a token in memory from a previous `getToken()` call.\r\n     */\n\n    let token = state.token;\n    let error = undefined;\n    /**\r\n     * If there is no token in memory, try to load token from indexedDB.\r\n     */\n\n    if (!token) {\n      // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n      const cachedToken = yield state.cachedTokenPromise;\n\n      if (cachedToken && isValid(cachedToken)) {\n        token = cachedToken;\n        setState(app, Object.assign(Object.assign({}, state), {\n          token\n        })); // notify all listeners with the cached token\n\n        notifyTokenListeners(app, {\n          token: token.token\n        });\n      }\n    } // Return the cached token (from either memory or indexedDB) if it's valid\n\n\n    if (!forceRefresh && token && isValid(token)) {\n      return {\n        token: token.token\n      };\n    }\n    /**\r\n     * DEBUG MODE\r\n     * If debug mode is set, and there is no cached token, fetch a new App\r\n     * Check token using the debug token, and return it directly.\r\n     */\n\n\n    if (isDebugMode()) {\n      const tokenFromDebugExchange = yield exchangeToken(getExchangeDebugTokenRequest(app, yield getDebugToken()), appCheck.platformLoggerProvider); // Write debug token to indexedDB.\n\n      yield writeTokenToStorage(app, tokenFromDebugExchange); // Write debug token to state.\n\n      setState(app, Object.assign(Object.assign({}, state), {\n        token: tokenFromDebugExchange\n      }));\n      return {\n        token: tokenFromDebugExchange.token\n      };\n    }\n    /**\r\n     * request a new token\r\n     */\n\n\n    try {\n      // state.provider is populated in initializeAppCheck()\n      // ensureActivated() at the top of this function checks that\n      // initializeAppCheck() has been called.\n      token = yield state.provider.getToken();\n    } catch (e) {\n      // `getToken()` should never throw, but logging error text to console will aid debugging.\n      logger.error(e);\n      error = e;\n    }\n\n    let interopTokenResult;\n\n    if (!token) {\n      // if token is undefined, there must be an error.\n      // we return a dummy token along with the error\n      interopTokenResult = makeDummyTokenResult(error);\n    } else {\n      interopTokenResult = {\n        token: token.token\n      }; // write the new token to the memory state as well as the persistent storage.\n      // Only do it if we got a valid new token\n\n      setState(app, Object.assign(Object.assign({}, state), {\n        token\n      }));\n      yield writeTokenToStorage(app, token);\n    }\n\n    notifyTokenListeners(app, interopTokenResult);\n    return interopTokenResult;\n  });\n  return _getToken$.apply(this, arguments);\n}\n\nfunction addTokenListener(appCheck, type, listener, onError) {\n  const {\n    app\n  } = appCheck;\n  const state = getState(app);\n  const tokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  const newState = Object.assign(Object.assign({}, state), {\n    tokenObservers: [...state.tokenObservers, tokenObserver]\n  });\n  /**\r\n   * Invoke the listener with the valid token, then start the token refresher\r\n   */\n\n  if (!newState.tokenRefresher) {\n    const tokenRefresher = createTokenRefresher(appCheck);\n    newState.tokenRefresher = tokenRefresher;\n  } // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n\n\n  if (!newState.tokenRefresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n    newState.tokenRefresher.start();\n  } // Invoke the listener async immediately if there is a valid token\n  // in memory.\n\n\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve().then(() => listener({\n      token: validToken.token\n    })).catch(() => {\n      /* we don't care about exceptions thrown in listeners */\n    });\n  } else if (state.token == null) {\n    // Only check cache if there was no token. If the token was invalid,\n    // skip this and rely on exchange endpoint.\n    void state.cachedTokenPromise // Storage token promise. Always populated in `activate()`.\n    .then(cachedToken => {\n      if (cachedToken && isValid(cachedToken)) {\n        listener({\n          token: cachedToken.token\n        });\n      }\n    }).catch(() => {\n      /** Ignore errors in listeners. */\n    });\n  }\n\n  setState(app, newState);\n}\n\nfunction removeTokenListener(app, listener) {\n  const state = getState(app);\n  const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n\n  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n\n  setState(app, Object.assign(Object.assign({}, state), {\n    tokenObservers: newObservers\n  }));\n}\n\nfunction createTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  return new Refresher(\n  /*#__PURE__*/\n  // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  _asyncToGenerator(function* () {\n    const state = getState(app); // If there is no token, we will try to load it from storage and use it\n    // If there is a token, we force refresh it because we know it's going to expire soon\n\n    let result;\n\n    if (!state.token) {\n      result = yield getToken$2(appCheck);\n    } else {\n      result = yield getToken$2(appCheck, true);\n    } // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\n\n\n    if (result.error) {\n      throw result.error;\n    }\n  }), () => {\n    // TODO: when should we retry?\n    return true;\n  }, () => {\n    const state = getState(app);\n\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000; // Do not allow refresh time to be past (expireTime - 5 minutes)\n\n      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\n\nfunction notifyTokenListeners(app, token) {\n  const observers = getState(app).tokenObservers;\n\n  for (const observer of observers) {\n    try {\n      if (observer.type === \"EXTERNAL\"\n      /* EXTERNAL */\n      && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (e) {// Errors in the listener function itself are always ignored.\n    }\n  }\n}\n\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\n\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * AppCheck Service class.\r\n */\n\n\nclass AppCheckService {\n  constructor(app, platformLoggerProvider) {\n    this.app = app;\n    this.platformLoggerProvider = platformLoggerProvider;\n  }\n\n  _delete() {\n    const {\n      tokenObservers\n    } = getState(this.app);\n\n    for (const tokenObserver of tokenObservers) {\n      removeTokenListener(this.app, tokenObserver.next);\n    }\n\n    return Promise.resolve();\n  }\n\n}\n\nfunction factory(app, platformLoggerProvider) {\n  return new AppCheckService(app, platformLoggerProvider);\n}\n\nfunction internalFactory(appCheck) {\n  return {\n    getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n    addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\"\n    /* INTERNAL */\n    , listener),\n    removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n  };\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.5.1\";\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\n\nfunction initializeV3(app, siteKey) {\n  const state = getState(app);\n  const initialized = new Deferred();\n  setState(app, Object.assign(Object.assign({}, state), {\n    reCAPTCHAState: {\n      initialized\n    }\n  }));\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(false);\n\n  if (!grecaptcha) {\n    loadReCAPTCHAV3Script(() => {\n      const grecaptcha = getRecaptcha(false);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n\n  return initialized.promise;\n}\n\nfunction initializeEnterprise(app, siteKey) {\n  const state = getState(app);\n  const initialized = new Deferred();\n  setState(app, Object.assign(Object.assign({}, state), {\n    reCAPTCHAState: {\n      initialized\n    }\n  }));\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(true);\n\n  if (!grecaptcha) {\n    loadReCAPTCHAEnterpriseScript(() => {\n      const grecaptcha = getRecaptcha(true);\n\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n\n  return initialized.promise;\n}\n/**\r\n * Add listener to render the widget and resolve the promise when\r\n * the grecaptcha.ready() event fires.\r\n */\n\n\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n  grecaptcha.ready(() => {\n    // Invisible widgets allow us to set a different siteKey for each widget,\n    // so we use them to support multiple apps\n    renderInvisibleWidget(app, siteKey, grecaptcha, container);\n    initialized.resolve(grecaptcha);\n  });\n}\n/**\r\n * Add invisible div to page.\r\n */\n\n\nfunction makeDiv(app) {\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  return divId;\n}\n\nfunction getToken$1(_x8) {\n  return _getToken$2.apply(this, arguments);\n}\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\n\n\nfunction _getToken$2() {\n  _getToken$2 = _asyncToGenerator(function* (app) {\n    ensureActivated(app); // ensureActivated() guarantees that reCAPTCHAState is set\n\n    const reCAPTCHAState = getState(app).reCAPTCHAState;\n    const recaptcha = yield reCAPTCHAState.initialized.promise;\n    return new Promise((resolve, _reject) => {\n      // Updated after initialization is complete.\n      const reCAPTCHAState = getState(app).reCAPTCHAState;\n      recaptcha.ready(() => {\n        resolve( // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId, {\n          action: 'fire_app_check'\n        }));\n      });\n    });\n  });\n  return _getToken$2.apply(this, arguments);\n}\n\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible'\n  });\n  const state = getState(app);\n  setState(app, Object.assign(Object.assign({}, state), {\n    reCAPTCHAState: Object.assign(Object.assign({}, state.reCAPTCHAState), {\n      // state.reCAPTCHAState is set in the initialize()\n      widgetId\n    })\n  }));\n}\n\nfunction loadReCAPTCHAV3Script(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_ENTERPRISE_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\n\n\nclass ReCaptchaV3Provider {\n  /**\r\n   * Create a ReCaptchaV3Provider instance.\r\n   * @param siteKey - ReCAPTCHA V3 siteKey.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._platformLoggerProvider are available.\n      const attestedClaimsToken = yield getToken$1(_this2._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* RECAPTCHA_ERROR */\n        );\n      });\n      return exchangeToken(getExchangeRecaptchaV3TokenRequest(_this2._app, attestedClaimsToken), _this2._platformLoggerProvider);\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n    this._platformLoggerProvider = _getProvider(app, 'platform-logger');\n    initializeV3(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaV3Provider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\n\n\nclass ReCaptchaEnterpriseProvider {\n  /**\r\n   * Create a ReCaptchaEnterpriseProvider instance.\r\n   * @param siteKey - reCAPTCHA Enterprise score-based site key.\r\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n  }\n  /**\r\n   * Returns an App Check token.\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._platformLoggerProvider are available.\n      const attestedClaimsToken = yield getToken$1(_this3._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\"\n        /* RECAPTCHA_ERROR */\n        );\n      });\n      return exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(_this3._app, attestedClaimsToken), _this3._platformLoggerProvider);\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n    this._platformLoggerProvider = _getProvider(app, 'platform-logger');\n    initializeEnterprise(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * Custom provider class.\r\n * @public\r\n */\n\n\nclass CustomProvider {\n  constructor(_customProviderOptions) {\n    this._customProviderOptions = _customProviderOptions;\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  getToken() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // custom provider\n      const customToken = yield _this4._customProviderOptions.getToken(); // Try to extract IAT from custom token, in case this token is not\n      // being newly issued. JWT timestamps are in seconds since epoch.\n\n      const issuedAtTimeSeconds = issuedAtTime(customToken.token); // Very basic validation, use current timestamp as IAT if JWT\n      // has no `iat` field or value is out of bounds.\n\n      const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n      return Object.assign(Object.assign({}, customToken), {\n        issuedAtTimeMillis\n      });\n    })();\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  initialize(app) {\n    this._app = app;\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  isEqual(otherProvider) {\n    if (otherProvider instanceof CustomProvider) {\n      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();\n    } else {\n      return false;\n    }\n  }\n\n}\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Activate App Check for the given app. Can be called only once per app.\r\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\r\n * @param options - App Check initialization options\r\n * @public\r\n */\n\n\nfunction initializeAppCheck(app = getApp(), options) {\n  app = getModularInstance(app);\n\n  const provider = _getProvider(app, 'app-check'); // Ensure initializeDebugMode() is only called once.\n\n\n  if (!getDebugState().initialized) {\n    initializeDebugMode();\n  } // Log a message containing the debug token when `initializeAppCheck()`\n  // is called in debug mode.\n\n\n  if (isDebugMode()) {\n    // Do not block initialization to get the token for the message.\n    void getDebugToken().then(token => // Not using logger because I don't think we ever want this accidentally hidden.\n    console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n  }\n\n  if (provider.isInitialized()) {\n    const existingInstance = provider.getImmediate();\n    const initialOptions = provider.getOptions();\n\n    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\"\n      /* ALREADY_INITIALIZED */\n      , {\n        appName: app.name\n      });\n    }\n  }\n\n  const appCheck = provider.initialize({\n    options\n  });\n\n  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n\n  return appCheck;\n}\n/**\r\n * Activate App Check\r\n * @param app - Firebase app to activate App Check for.\r\n * @param provider - reCAPTCHA v3 provider or\r\n * custom token provider.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. If undefined, defaults to the\r\n * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n * false and can be set in the app config.\r\n */\n\n\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\n  const state = getState(app);\n  const newState = Object.assign(Object.assign({}, state), {\n    activated: true\n  });\n  newState.provider = provider; // Read cached token from storage if it exists and store it in memory.\n\n  newState.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n    if (cachedToken && isValid(cachedToken)) {\n      setState(app, Object.assign(Object.assign({}, getState(app)), {\n        token: cachedToken\n      }));\n    }\n\n    return cachedToken;\n  }); // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n\n  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  setState(app, newState);\n  newState.provider.initialize(app);\n}\n/**\r\n * Set whether App Check will automatically refresh tokens as needed.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. This overrides any value set\r\n * during `initializeAppCheck()`.\r\n * @public\r\n */\n\n\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n  const app = appCheckInstance.app;\n  const state = getState(app); // This will exist if any product libraries have called\n  // `addTokenListener()`\n\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n\n  setState(app, Object.assign(Object.assign({}, state), {\n    isTokenAutoRefreshEnabled\n  }));\n}\n/**\r\n * Get the current App Check token. Attaches to the most recent\r\n * in-flight request if one is present. Returns null if no token\r\n * is present and no token requests are in-flight.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n * If false, will use a cached token if found in storage.\r\n * @public\r\n */\n\n\nfunction getToken(_x9, _x10) {\n  return _getToken.apply(this, arguments);\n}\n/**\r\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\r\n * pattern for public use.\r\n */\n\n\nfunction _getToken() {\n  _getToken = _asyncToGenerator(function* (appCheckInstance, forceRefresh) {\n    const result = yield getToken$2(appCheckInstance, forceRefresh);\n\n    if (result.error) {\n      throw result.error;\n    }\n\n    return {\n      token: result.token\n    };\n  });\n  return _getToken.apply(this, arguments);\n}\n\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError,\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n  let nextFn = () => {};\n\n  let errorFn = () => {};\n\n  if (onNextOrObserver.next != null) {\n    nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver;\n  }\n\n  if (onNextOrObserver.error != null) {\n    errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n\n  addTokenListener(appCheckInstance, \"EXTERNAL\"\n  /* EXTERNAL */\n  , nextFn, errorFn);\n  return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n/**\r\n * Firebase App Check\r\n *\r\n * @packageDocumentation\r\n */\n\n\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\n\nfunction registerAppCheck() {\n  // The public interface\n  _registerComponent(new Component(APP_CHECK_NAME, container => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const platformLoggerProvider = container.getProvider('platform-logger');\n    return factory(app, platformLoggerProvider);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  ).setInstantiationMode(\"EXPLICIT\"\n  /* EXPLICIT */\n  )\n  /**\r\n   * Initialize app-check-internal after app-check is initialized to make AppCheck available to\r\n   * other Firebase SDKs\r\n   */\n  .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n  })); // The internal interface used by other Firebase products\n\n\n  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n    const appCheck = container.getProvider('app-check').getImmediate();\n    return internalFactory(appCheck);\n  }, \"PUBLIC\"\n  /* PUBLIC */\n  ).setInstantiationMode(\"EXPLICIT\"\n  /* EXPLICIT */\n  ));\n\n  registerVersion(name, version);\n}\n\nregisterAppCheck();\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };","map":{"version":3,"sources":["D:/Angular/Lab/node_modules/@firebase/app-check/dist/esm/index.esm2017.js"],"names":["_getProvider","getApp","_registerComponent","registerVersion","Component","Deferred","ErrorFactory","isIndexedDBAvailable","getGlobal","base64","issuedAtTime","getModularInstance","Logger","APP_CHECK_STATES","Map","DEFAULT_STATE","activated","tokenObservers","DEBUG_STATE","initialized","enabled","getState","app","get","setState","state","set","getDebugState","BASE_ENDPOINT","EXCHANGE_RECAPTCHA_TOKEN_METHOD","EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD","EXCHANGE_DEBUG_TOKEN_METHOD","TOKEN_REFRESH_TIME","OFFSET_DURATION","RETRIAL_MIN_WAIT","RETRIAL_MAX_WAIT","Refresher","constructor","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","pending","nextErrorWaitInterval","Error","start","process","catch","stop","reject","isRunning","hasSucceeded","sleep","getNextRun","resolve","promise","error","currentErrorWaitInterval","ms","Promise","setTimeout","ERRORS","ERROR_FACTORY","getRecaptcha","isEnterprise","_a","self","grecaptcha","enterprise","ensureActivated","create","appName","name","uuidv4","replace","c","r","Math","random","v","toString","exchangeToken","url","body","platformLoggerProvider","headers","platformLogger","getImmediate","optional","getPlatformInfoString","options","method","JSON","stringify","response","fetch","originalError","originalErrorMessage","message","status","httpStatus","responseBody","json","match","ttl","isNaN","Number","timeToLiveAsNumber","now","Date","token","attestationToken","expireTimeMillis","issuedAtTimeMillis","getExchangeRecaptchaV3TokenRequest","reCAPTCHAToken","projectId","appId","apiKey","getExchangeRecaptchaEnterpriseTokenRequest","getExchangeDebugTokenRequest","debugToken","debug_token","DB_NAME","DB_VERSION","STORE_NAME","DEBUG_TOKEN_KEY","dbPromise","getDBPromise","request","indexedDB","open","onsuccess","event","target","result","onerror","onupgradeneeded","db","oldVersion","createObjectStore","keyPath","e","readTokenFromIndexedDB","read","computeKey","writeTokenToIndexedDB","write","writeDebugTokenToIndexedDB","readDebugTokenFromIndexedDB","key","value","transaction","store","objectStore","put","compositeKey","_event","undefined","logger","readTokenFromStorage","warn","writeTokenToStorage","readOrCreateDebugTokenFromStorage","existingDebugToken","_e","newToken","isDebugMode","debugState","getDebugToken","initializeDebugMode","globals","FIREBASE_APPCHECK_DEBUG_TOKEN","deferredToken","defaultTokenErrorData","formatDummyToken","tokenErrorData","encodeString","getToken$2","appCheck","forceRefresh","cachedToken","cachedTokenPromise","isValid","Object","assign","notifyTokenListeners","tokenFromDebugExchange","provider","getToken","interopTokenResult","makeDummyTokenResult","addTokenListener","type","listener","onError","tokenObserver","next","newState","tokenRefresher","createTokenRefresher","isTokenAutoRefreshEnabled","validToken","then","removeTokenListener","newObservers","filter","length","nextRefreshTimeMillis","latestAllowableRefresh","min","max","observers","observer","AppCheckService","_delete","factory","internalFactory","version","RECAPTCHA_URL","RECAPTCHA_ENTERPRISE_URL","initializeV3","siteKey","reCAPTCHAState","divId","makeDiv","loadReCAPTCHAV3Script","queueWidgetRender","initializeEnterprise","loadReCAPTCHAEnterpriseScript","container","ready","renderInvisibleWidget","invisibleDiv","document","createElement","id","style","display","appendChild","getToken$1","recaptcha","_reject","execute","widgetId","action","render","sitekey","size","onload","script","src","head","ReCaptchaV3Provider","_siteKey","attestedClaimsToken","_app","_platformLoggerProvider","initialize","isEqual","otherProvider","ReCaptchaEnterpriseProvider","CustomProvider","_customProviderOptions","customToken","issuedAtTimeSeconds","initializeAppCheck","console","log","isInitialized","existingInstance","initialOptions","getOptions","_activate","automaticDataCollectionEnabled","setTokenAutoRefreshEnabled","appCheckInstance","onTokenChanged","onNextOrObserver","onCompletion","nextFn","errorFn","bind","APP_CHECK_NAME","APP_CHECK_NAME_INTERNAL","registerAppCheck","getProvider","setInstantiationMode","setInstanceCreatedCallback","_identifier","_appcheckService"],"mappings":"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","sourcesContent":["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, getGlobal, base64, issuedAtTime, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst APP_CHECK_STATES = new Map();\r\nconst DEFAULT_STATE = {\r\n    activated: false,\r\n    tokenObservers: []\r\n};\r\nconst DEBUG_STATE = {\r\n    initialized: false,\r\n    enabled: false\r\n};\r\nfunction getState(app) {\r\n    return APP_CHECK_STATES.get(app) || DEFAULT_STATE;\r\n}\r\nfunction setState(app, state) {\r\n    APP_CHECK_STATES.set(app, state);\r\n}\r\nfunction getDebugState() {\r\n    return DEBUG_STATE;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1beta';\r\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaToken';\r\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\r\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\r\nconst TOKEN_REFRESH_TIME = {\r\n    /**\r\n     * The offset time before token natural expiration to run the refresh.\r\n     * This is currently 5 minutes.\r\n     */\r\n    OFFSET_DURATION: 5 * 60 * 1000,\r\n    /**\r\n     * This is the first retrial wait after an error. This is currently\r\n     * 30 seconds.\r\n     */\r\n    RETRIAL_MIN_WAIT: 30 * 1000,\r\n    /**\r\n     * This is the maximum retrial wait, currently 16 minutes.\r\n     */\r\n    RETRIAL_MAX_WAIT: 16 * 60 * 1000\r\n};\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Port from auth proactiverefresh.js\r\n *\r\n */\r\n// TODO: move it to @firebase/util?\r\n// TODO: allow to config whether refresh should happen in the background\r\nclass Refresher {\r\n    constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\r\n        this.operation = operation;\r\n        this.retryPolicy = retryPolicy;\r\n        this.getWaitDuration = getWaitDuration;\r\n        this.lowerBound = lowerBound;\r\n        this.upperBound = upperBound;\r\n        this.pending = null;\r\n        this.nextErrorWaitInterval = lowerBound;\r\n        if (lowerBound > upperBound) {\r\n            throw new Error('Proactive refresh lower bound greater than upper bound!');\r\n        }\r\n    }\r\n    start() {\r\n        this.nextErrorWaitInterval = this.lowerBound;\r\n        this.process(true).catch(() => {\r\n            /* we don't care about the result */\r\n        });\r\n    }\r\n    stop() {\r\n        if (this.pending) {\r\n            this.pending.reject('cancelled');\r\n            this.pending = null;\r\n        }\r\n    }\r\n    isRunning() {\r\n        return !!this.pending;\r\n    }\r\n    async process(hasSucceeded) {\r\n        this.stop();\r\n        try {\r\n            this.pending = new Deferred();\r\n            await sleep(this.getNextRun(hasSucceeded));\r\n            // Why do we resolve a promise, then immediate wait for it?\r\n            // We do it to make the promise chain cancellable.\r\n            // We can call stop() which rejects the promise before the following line execute, which makes\r\n            // the code jump to the catch block.\r\n            // TODO: unit test this\r\n            this.pending.resolve();\r\n            await this.pending.promise;\r\n            this.pending = new Deferred();\r\n            await this.operation();\r\n            this.pending.resolve();\r\n            await this.pending.promise;\r\n            this.process(true).catch(() => {\r\n                /* we don't care about the result */\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (this.retryPolicy(error)) {\r\n                this.process(false).catch(() => {\r\n                    /* we don't care about the result */\r\n                });\r\n            }\r\n            else {\r\n                this.stop();\r\n            }\r\n        }\r\n    }\r\n    getNextRun(hasSucceeded) {\r\n        if (hasSucceeded) {\r\n            // If last operation succeeded, reset next error wait interval and return\r\n            // the default wait duration.\r\n            this.nextErrorWaitInterval = this.lowerBound;\r\n            // Return typical wait duration interval after a successful operation.\r\n            return this.getWaitDuration();\r\n        }\r\n        else {\r\n            // Get next error wait interval.\r\n            const currentErrorWaitInterval = this.nextErrorWaitInterval;\r\n            // Double interval for next consecutive error.\r\n            this.nextErrorWaitInterval *= 2;\r\n            // Make sure next wait interval does not exceed the maximum upper bound.\r\n            if (this.nextErrorWaitInterval > this.upperBound) {\r\n                this.nextErrorWaitInterval = this.upperBound;\r\n            }\r\n            return currentErrorWaitInterval;\r\n        }\r\n    }\r\n}\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-initialized\" /* ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' +\r\n        'different options. To avoid this error, call initializeAppCheck() with the ' +\r\n        'same options as when it was originally called. This will return the ' +\r\n        'already initialized instance.',\r\n    [\"use-before-activation\" /* USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' +\r\n        'Call initializeAppCheck() before instantiating other Firebase services.',\r\n    [\"fetch-network-error\" /* FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' +\r\n        'Original error: {$originalErrorMessage}.',\r\n    [\"fetch-parse-error\" /* FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' +\r\n        ' Original error: {$originalErrorMessage}.',\r\n    [\"fetch-status-error\" /* FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\r\n    [\"storage-open\" /* STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\r\n    [\"storage-get\" /* STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\r\n    [\"storage-set\" /* STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\r\n    [\"recaptcha-error\" /* RECAPTCHA_ERROR */]: 'ReCAPTCHA error.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getRecaptcha(isEnterprise = false) {\r\n    var _a;\r\n    if (isEnterprise) {\r\n        return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\r\n    }\r\n    return self.grecaptcha;\r\n}\r\nfunction ensureActivated(app) {\r\n    if (!getState(app).activated) {\r\n        throw ERROR_FACTORY.create(\"use-before-activation\" /* USE_BEFORE_ACTIVATION */, {\r\n            appName: app.name\r\n        });\r\n    }\r\n}\r\n/**\r\n * Copied from https://stackoverflow.com/a/2117523\r\n */\r\nfunction uuidv4() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\r\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function exchangeToken({ url, body }, platformLoggerProvider) {\r\n    const headers = {\r\n        'Content-Type': 'application/json'\r\n    };\r\n    // If platform logger exists, add the platform info string to the header.\r\n    const platformLogger = platformLoggerProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (platformLogger) {\r\n        headers['X-Firebase-Client'] = platformLogger.getPlatformInfoString();\r\n    }\r\n    const options = {\r\n        method: 'POST',\r\n        body: JSON.stringify(body),\r\n        headers\r\n    };\r\n    let response;\r\n    try {\r\n        response = await fetch(url, options);\r\n    }\r\n    catch (originalError) {\r\n        throw ERROR_FACTORY.create(\"fetch-network-error\" /* FETCH_NETWORK_ERROR */, {\r\n            originalErrorMessage: originalError.message\r\n        });\r\n    }\r\n    if (response.status !== 200) {\r\n        throw ERROR_FACTORY.create(\"fetch-status-error\" /* FETCH_STATUS_ERROR */, {\r\n            httpStatus: response.status\r\n        });\r\n    }\r\n    let responseBody;\r\n    try {\r\n        // JSON parsing throws SyntaxError if the response body isn't a JSON string.\r\n        responseBody = await response.json();\r\n    }\r\n    catch (originalError) {\r\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* FETCH_PARSE_ERROR */, {\r\n            originalErrorMessage: originalError.message\r\n        });\r\n    }\r\n    // Protobuf duration format.\r\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\r\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\r\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\r\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* FETCH_PARSE_ERROR */, {\r\n            originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` +\r\n                `format: ${responseBody.ttl}`\r\n        });\r\n    }\r\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\r\n    const now = Date.now();\r\n    return {\r\n        token: responseBody.attestationToken,\r\n        expireTimeMillis: now + timeToLiveAsNumber,\r\n        issuedAtTimeMillis: now\r\n    };\r\n}\r\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            'recaptcha_token': reCAPTCHAToken\r\n        }\r\n    };\r\n}\r\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            'recaptcha_enterprise_token': reCAPTCHAToken\r\n        }\r\n    };\r\n}\r\nfunction getExchangeDebugTokenRequest(app, debugToken) {\r\n    const { projectId, appId, apiKey } = app.options;\r\n    return {\r\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\r\n        body: {\r\n            // eslint-disable-next-line\r\n            debug_token: debugToken\r\n        }\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DB_NAME = 'firebase-app-check-database';\r\nconst DB_VERSION = 1;\r\nconst STORE_NAME = 'firebase-app-check-store';\r\nconst DEBUG_TOKEN_KEY = 'debug-token';\r\nlet dbPromise = null;\r\nfunction getDBPromise() {\r\n    if (dbPromise) {\r\n        return dbPromise;\r\n    }\r\n    dbPromise = new Promise((resolve, reject) => {\r\n        try {\r\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\r\n            request.onsuccess = event => {\r\n                resolve(event.target.result);\r\n            };\r\n            request.onerror = event => {\r\n                var _a;\r\n                reject(ERROR_FACTORY.create(\"storage-open\" /* STORAGE_OPEN */, {\r\n                    originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n                }));\r\n            };\r\n            request.onupgradeneeded = event => {\r\n                const db = event.target.result;\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (event.oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(STORE_NAME, {\r\n                            keyPath: 'compositeKey'\r\n                        });\r\n                }\r\n            };\r\n        }\r\n        catch (e) {\r\n            reject(ERROR_FACTORY.create(\"storage-open\" /* STORAGE_OPEN */, {\r\n                originalErrorMessage: e.message\r\n            }));\r\n        }\r\n    });\r\n    return dbPromise;\r\n}\r\nfunction readTokenFromIndexedDB(app) {\r\n    return read(computeKey(app));\r\n}\r\nfunction writeTokenToIndexedDB(app, token) {\r\n    return write(computeKey(app), token);\r\n}\r\nfunction writeDebugTokenToIndexedDB(token) {\r\n    return write(DEBUG_TOKEN_KEY, token);\r\n}\r\nfunction readDebugTokenFromIndexedDB() {\r\n    return read(DEBUG_TOKEN_KEY);\r\n}\r\nasync function write(key, value) {\r\n    const db = await getDBPromise();\r\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.put({\r\n        compositeKey: key,\r\n        value\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        request.onsuccess = _event => {\r\n            resolve();\r\n        };\r\n        transaction.onerror = event => {\r\n            var _a;\r\n            reject(ERROR_FACTORY.create(\"storage-set\" /* STORAGE_WRITE */, {\r\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n            }));\r\n        };\r\n    });\r\n}\r\nasync function read(key) {\r\n    const db = await getDBPromise();\r\n    const transaction = db.transaction(STORE_NAME, 'readonly');\r\n    const store = transaction.objectStore(STORE_NAME);\r\n    const request = store.get(key);\r\n    return new Promise((resolve, reject) => {\r\n        request.onsuccess = event => {\r\n            const result = event.target.result;\r\n            if (result) {\r\n                resolve(result.value);\r\n            }\r\n            else {\r\n                resolve(undefined);\r\n            }\r\n        };\r\n        transaction.onerror = event => {\r\n            var _a;\r\n            reject(ERROR_FACTORY.create(\"storage-get\" /* STORAGE_GET */, {\r\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\r\n            }));\r\n        };\r\n    });\r\n}\r\nfunction computeKey(app) {\r\n    return `${app.options.appId}-${app.name}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/app-check');\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\r\n */\r\nasync function readTokenFromStorage(app) {\r\n    if (isIndexedDBAvailable()) {\r\n        let token = undefined;\r\n        try {\r\n            token = await readTokenFromIndexedDB(app);\r\n        }\r\n        catch (e) {\r\n            // swallow the error and return undefined\r\n            logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\r\n        }\r\n        return token;\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\r\n */\r\nfunction writeTokenToStorage(app, token) {\r\n    if (isIndexedDBAvailable()) {\r\n        return writeTokenToIndexedDB(app, token).catch(e => {\r\n            // swallow the error and resolve the promise\r\n            logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\r\n        });\r\n    }\r\n    return Promise.resolve();\r\n}\r\nasync function readOrCreateDebugTokenFromStorage() {\r\n    /**\r\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\r\n     * But it won't happen here, because this function will be called exactly once.\r\n     */\r\n    let existingDebugToken = undefined;\r\n    try {\r\n        existingDebugToken = await readDebugTokenFromIndexedDB();\r\n    }\r\n    catch (_e) {\r\n        // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\r\n    }\r\n    if (!existingDebugToken) {\r\n        // create a new debug token\r\n        const newToken = uuidv4();\r\n        // We don't need to block on writing to indexeddb\r\n        // In case persistence failed, a new debug token will be generated everytime the page is refreshed.\r\n        // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\r\n        // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\r\n        // You should switch to a different browser that supports indexeddb\r\n        writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\r\n        return newToken;\r\n    }\r\n    else {\r\n        return existingDebugToken;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction isDebugMode() {\r\n    const debugState = getDebugState();\r\n    return debugState.enabled;\r\n}\r\nasync function getDebugToken() {\r\n    const state = getDebugState();\r\n    if (state.enabled && state.token) {\r\n        return state.token.promise;\r\n    }\r\n    else {\r\n        // should not happen!\r\n        throw Error(`\n            Can't get debug token in production mode.\n        `);\r\n    }\r\n}\r\nfunction initializeDebugMode() {\r\n    const globals = getGlobal();\r\n    const debugState = getDebugState();\r\n    // Set to true if this function has been called, whether or not\r\n    // it enabled debug mode.\r\n    debugState.initialized = true;\r\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\r\n        globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\r\n        return;\r\n    }\r\n    debugState.enabled = true;\r\n    const deferredToken = new Deferred();\r\n    debugState.token = deferredToken;\r\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\r\n        deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\r\n    }\r\n    else {\r\n        deferredToken.resolve(readOrCreateDebugTokenFromStorage());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n// Initial hardcoded value agreed upon across platforms for initial launch.\r\n// Format left open for possible dynamic error values and other fields in the future.\r\nconst defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\r\n/**\r\n * Stringify and base64 encode token error data.\r\n *\r\n * @param tokenError Error data, currently hardcoded.\r\n */\r\nfunction formatDummyToken(tokenErrorData) {\r\n    return base64.encodeString(JSON.stringify(tokenErrorData), \r\n    /* webSafe= */ false);\r\n}\r\n/**\r\n * This function always resolves.\r\n * The result will contain an error field if there is any error.\r\n * In case there is an error, the token field in the result will be populated with a dummy value\r\n */\r\nasync function getToken$2(appCheck, forceRefresh = false) {\r\n    const app = appCheck.app;\r\n    ensureActivated(app);\r\n    const state = getState(app);\r\n    /**\r\n     * First check if there is a token in memory from a previous `getToken()` call.\r\n     */\r\n    let token = state.token;\r\n    let error = undefined;\r\n    /**\r\n     * If there is no token in memory, try to load token from indexedDB.\r\n     */\r\n    if (!token) {\r\n        // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\r\n        const cachedToken = await state.cachedTokenPromise;\r\n        if (cachedToken && isValid(cachedToken)) {\r\n            token = cachedToken;\r\n            setState(app, Object.assign(Object.assign({}, state), { token }));\r\n            // notify all listeners with the cached token\r\n            notifyTokenListeners(app, { token: token.token });\r\n        }\r\n    }\r\n    // Return the cached token (from either memory or indexedDB) if it's valid\r\n    if (!forceRefresh && token && isValid(token)) {\r\n        return {\r\n            token: token.token\r\n        };\r\n    }\r\n    /**\r\n     * DEBUG MODE\r\n     * If debug mode is set, and there is no cached token, fetch a new App\r\n     * Check token using the debug token, and return it directly.\r\n     */\r\n    if (isDebugMode()) {\r\n        const tokenFromDebugExchange = await exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.platformLoggerProvider);\r\n        // Write debug token to indexedDB.\r\n        await writeTokenToStorage(app, tokenFromDebugExchange);\r\n        // Write debug token to state.\r\n        setState(app, Object.assign(Object.assign({}, state), { token: tokenFromDebugExchange }));\r\n        return { token: tokenFromDebugExchange.token };\r\n    }\r\n    /**\r\n     * request a new token\r\n     */\r\n    try {\r\n        // state.provider is populated in initializeAppCheck()\r\n        // ensureActivated() at the top of this function checks that\r\n        // initializeAppCheck() has been called.\r\n        token = await state.provider.getToken();\r\n    }\r\n    catch (e) {\r\n        // `getToken()` should never throw, but logging error text to console will aid debugging.\r\n        logger.error(e);\r\n        error = e;\r\n    }\r\n    let interopTokenResult;\r\n    if (!token) {\r\n        // if token is undefined, there must be an error.\r\n        // we return a dummy token along with the error\r\n        interopTokenResult = makeDummyTokenResult(error);\r\n    }\r\n    else {\r\n        interopTokenResult = {\r\n            token: token.token\r\n        };\r\n        // write the new token to the memory state as well as the persistent storage.\r\n        // Only do it if we got a valid new token\r\n        setState(app, Object.assign(Object.assign({}, state), { token }));\r\n        await writeTokenToStorage(app, token);\r\n    }\r\n    notifyTokenListeners(app, interopTokenResult);\r\n    return interopTokenResult;\r\n}\r\nfunction addTokenListener(appCheck, type, listener, onError) {\r\n    const { app } = appCheck;\r\n    const state = getState(app);\r\n    const tokenObserver = {\r\n        next: listener,\r\n        error: onError,\r\n        type\r\n    };\r\n    const newState = Object.assign(Object.assign({}, state), { tokenObservers: [...state.tokenObservers, tokenObserver] });\r\n    /**\r\n     * Invoke the listener with the valid token, then start the token refresher\r\n     */\r\n    if (!newState.tokenRefresher) {\r\n        const tokenRefresher = createTokenRefresher(appCheck);\r\n        newState.tokenRefresher = tokenRefresher;\r\n    }\r\n    // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\r\n    // is not true.\r\n    if (!newState.tokenRefresher.isRunning() && state.isTokenAutoRefreshEnabled) {\r\n        newState.tokenRefresher.start();\r\n    }\r\n    // Invoke the listener async immediately if there is a valid token\r\n    // in memory.\r\n    if (state.token && isValid(state.token)) {\r\n        const validToken = state.token;\r\n        Promise.resolve()\r\n            .then(() => listener({ token: validToken.token }))\r\n            .catch(() => {\r\n            /* we don't care about exceptions thrown in listeners */\r\n        });\r\n    }\r\n    else if (state.token == null) {\r\n        // Only check cache if there was no token. If the token was invalid,\r\n        // skip this and rely on exchange endpoint.\r\n        void state\r\n            .cachedTokenPromise // Storage token promise. Always populated in `activate()`.\r\n            .then(cachedToken => {\r\n            if (cachedToken && isValid(cachedToken)) {\r\n                listener({ token: cachedToken.token });\r\n            }\r\n        })\r\n            .catch(() => {\r\n            /** Ignore errors in listeners. */\r\n        });\r\n    }\r\n    setState(app, newState);\r\n}\r\nfunction removeTokenListener(app, listener) {\r\n    const state = getState(app);\r\n    const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\r\n    if (newObservers.length === 0 &&\r\n        state.tokenRefresher &&\r\n        state.tokenRefresher.isRunning()) {\r\n        state.tokenRefresher.stop();\r\n    }\r\n    setState(app, Object.assign(Object.assign({}, state), { tokenObservers: newObservers }));\r\n}\r\nfunction createTokenRefresher(appCheck) {\r\n    const { app } = appCheck;\r\n    return new Refresher(\r\n    // Keep in mind when this fails for any reason other than the ones\r\n    // for which we should retry, it will effectively stop the proactive refresh.\r\n    async () => {\r\n        const state = getState(app);\r\n        // If there is no token, we will try to load it from storage and use it\r\n        // If there is a token, we force refresh it because we know it's going to expire soon\r\n        let result;\r\n        if (!state.token) {\r\n            result = await getToken$2(appCheck);\r\n        }\r\n        else {\r\n            result = await getToken$2(appCheck, true);\r\n        }\r\n        // getToken() always resolves. In case the result has an error field defined, it means the operation failed, and we should retry.\r\n        if (result.error) {\r\n            throw result.error;\r\n        }\r\n    }, () => {\r\n        // TODO: when should we retry?\r\n        return true;\r\n    }, () => {\r\n        const state = getState(app);\r\n        if (state.token) {\r\n            // issuedAtTime + (50% * total TTL) + 5 minutes\r\n            let nextRefreshTimeMillis = state.token.issuedAtTimeMillis +\r\n                (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\r\n                    0.5 +\r\n                5 * 60 * 1000;\r\n            // Do not allow refresh time to be past (expireTime - 5 minutes)\r\n            const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\r\n            nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\r\n            return Math.max(0, nextRefreshTimeMillis - Date.now());\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\r\n}\r\nfunction notifyTokenListeners(app, token) {\r\n    const observers = getState(app).tokenObservers;\r\n    for (const observer of observers) {\r\n        try {\r\n            if (observer.type === \"EXTERNAL\" /* EXTERNAL */ && token.error != null) {\r\n                // If this listener was added by a 3P call, send any token error to\r\n                // the supplied error handler. A 3P observer always has an error\r\n                // handler.\r\n                observer.error(token.error);\r\n            }\r\n            else {\r\n                // If the token has no error field, always return the token.\r\n                // If this is a 2P listener, return the token, whether or not it\r\n                // has an error field.\r\n                observer.next(token);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Errors in the listener function itself are always ignored.\r\n        }\r\n    }\r\n}\r\nfunction isValid(token) {\r\n    return token.expireTimeMillis - Date.now() > 0;\r\n}\r\nfunction makeDummyTokenResult(error) {\r\n    return {\r\n        token: formatDummyToken(defaultTokenErrorData),\r\n        error\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * AppCheck Service class.\r\n */\r\nclass AppCheckService {\r\n    constructor(app, platformLoggerProvider) {\r\n        this.app = app;\r\n        this.platformLoggerProvider = platformLoggerProvider;\r\n    }\r\n    _delete() {\r\n        const { tokenObservers } = getState(this.app);\r\n        for (const tokenObserver of tokenObservers) {\r\n            removeTokenListener(this.app, tokenObserver.next);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n}\r\nfunction factory(app, platformLoggerProvider) {\r\n    return new AppCheckService(app, platformLoggerProvider);\r\n}\r\nfunction internalFactory(appCheck) {\r\n    return {\r\n        getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\r\n        addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* INTERNAL */, listener),\r\n        removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\r\n    };\r\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.5.1\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\r\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\r\nfunction initializeV3(app, siteKey) {\r\n    const state = getState(app);\r\n    const initialized = new Deferred();\r\n    setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));\r\n    const divId = makeDiv(app);\r\n    const grecaptcha = getRecaptcha(false);\r\n    if (!grecaptcha) {\r\n        loadReCAPTCHAV3Script(() => {\r\n            const grecaptcha = getRecaptcha(false);\r\n            if (!grecaptcha) {\r\n                // it shouldn't happen.\r\n                throw new Error('no recaptcha');\r\n            }\r\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n        });\r\n    }\r\n    else {\r\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n    }\r\n    return initialized.promise;\r\n}\r\nfunction initializeEnterprise(app, siteKey) {\r\n    const state = getState(app);\r\n    const initialized = new Deferred();\r\n    setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: { initialized } }));\r\n    const divId = makeDiv(app);\r\n    const grecaptcha = getRecaptcha(true);\r\n    if (!grecaptcha) {\r\n        loadReCAPTCHAEnterpriseScript(() => {\r\n            const grecaptcha = getRecaptcha(true);\r\n            if (!grecaptcha) {\r\n                // it shouldn't happen.\r\n                throw new Error('no recaptcha');\r\n            }\r\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n        });\r\n    }\r\n    else {\r\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\r\n    }\r\n    return initialized.promise;\r\n}\r\n/**\r\n * Add listener to render the widget and resolve the promise when\r\n * the grecaptcha.ready() event fires.\r\n */\r\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\r\n    grecaptcha.ready(() => {\r\n        // Invisible widgets allow us to set a different siteKey for each widget,\r\n        // so we use them to support multiple apps\r\n        renderInvisibleWidget(app, siteKey, grecaptcha, container);\r\n        initialized.resolve(grecaptcha);\r\n    });\r\n}\r\n/**\r\n * Add invisible div to page.\r\n */\r\nfunction makeDiv(app) {\r\n    const divId = `fire_app_check_${app.name}`;\r\n    const invisibleDiv = document.createElement('div');\r\n    invisibleDiv.id = divId;\r\n    invisibleDiv.style.display = 'none';\r\n    document.body.appendChild(invisibleDiv);\r\n    return divId;\r\n}\r\nasync function getToken$1(app) {\r\n    ensureActivated(app);\r\n    // ensureActivated() guarantees that reCAPTCHAState is set\r\n    const reCAPTCHAState = getState(app).reCAPTCHAState;\r\n    const recaptcha = await reCAPTCHAState.initialized.promise;\r\n    return new Promise((resolve, _reject) => {\r\n        // Updated after initialization is complete.\r\n        const reCAPTCHAState = getState(app).reCAPTCHAState;\r\n        recaptcha.ready(() => {\r\n            resolve(\r\n            // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\r\n            recaptcha.execute(reCAPTCHAState.widgetId, {\r\n                action: 'fire_app_check'\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n *\r\n * @param app\r\n * @param container - Id of a HTML element.\r\n */\r\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\r\n    const widgetId = grecaptcha.render(container, {\r\n        sitekey: siteKey,\r\n        size: 'invisible'\r\n    });\r\n    const state = getState(app);\r\n    setState(app, Object.assign(Object.assign({}, state), { reCAPTCHAState: Object.assign(Object.assign({}, state.reCAPTCHAState), { // state.reCAPTCHAState is set in the initialize()\r\n            widgetId }) }));\r\n}\r\nfunction loadReCAPTCHAV3Script(onload) {\r\n    const script = document.createElement('script');\r\n    script.src = RECAPTCHA_URL;\r\n    script.onload = onload;\r\n    document.head.appendChild(script);\r\n}\r\nfunction loadReCAPTCHAEnterpriseScript(onload) {\r\n    const script = document.createElement('script');\r\n    script.src = RECAPTCHA_ENTERPRISE_URL;\r\n    script.onload = onload;\r\n    document.head.appendChild(script);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2021 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\r\nclass ReCaptchaV3Provider {\r\n    /**\r\n     * Create a ReCaptchaV3Provider instance.\r\n     * @param siteKey - ReCAPTCHA V3 siteKey.\r\n     */\r\n    constructor(_siteKey) {\r\n        this._siteKey = _siteKey;\r\n    }\r\n    /**\r\n     * Returns an App Check token.\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        // Top-level `getToken()` has already checked that App Check is initialized\r\n        // and therefore this._app and this._platformLoggerProvider are available.\r\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\r\n            // reCaptcha.execute() throws null which is not very descriptive.\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* RECAPTCHA_ERROR */);\r\n        });\r\n        return exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._platformLoggerProvider);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n        this._platformLoggerProvider = _getProvider(app, 'platform-logger');\r\n        initializeV3(app, this._siteKey).catch(() => {\r\n            /* we don't care about the initialization result */\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof ReCaptchaV3Provider) {\r\n            return this._siteKey === otherProvider._siteKey;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\r\n * for an App Check token.\r\n *\r\n * @public\r\n */\r\nclass ReCaptchaEnterpriseProvider {\r\n    /**\r\n     * Create a ReCaptchaEnterpriseProvider instance.\r\n     * @param siteKey - reCAPTCHA Enterprise score-based site key.\r\n     */\r\n    constructor(_siteKey) {\r\n        this._siteKey = _siteKey;\r\n    }\r\n    /**\r\n     * Returns an App Check token.\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        // Top-level `getToken()` has already checked that App Check is initialized\r\n        // and therefore this._app and this._platformLoggerProvider are available.\r\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\r\n            // reCaptcha.execute() throws null which is not very descriptive.\r\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* RECAPTCHA_ERROR */);\r\n        });\r\n        return exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._platformLoggerProvider);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n        this._platformLoggerProvider = _getProvider(app, 'platform-logger');\r\n        initializeEnterprise(app, this._siteKey).catch(() => {\r\n            /* we don't care about the initialization result */\r\n        });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\r\n            return this._siteKey === otherProvider._siteKey;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Custom provider class.\r\n * @public\r\n */\r\nclass CustomProvider {\r\n    constructor(_customProviderOptions) {\r\n        this._customProviderOptions = _customProviderOptions;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    async getToken() {\r\n        // custom provider\r\n        const customToken = await this._customProviderOptions.getToken();\r\n        // Try to extract IAT from custom token, in case this token is not\r\n        // being newly issued. JWT timestamps are in seconds since epoch.\r\n        const issuedAtTimeSeconds = issuedAtTime(customToken.token);\r\n        // Very basic validation, use current timestamp as IAT if JWT\r\n        // has no `iat` field or value is out of bounds.\r\n        const issuedAtTimeMillis = issuedAtTimeSeconds !== null &&\r\n            issuedAtTimeSeconds < Date.now() &&\r\n            issuedAtTimeSeconds > 0\r\n            ? issuedAtTimeSeconds * 1000\r\n            : Date.now();\r\n        return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    initialize(app) {\r\n        this._app = app;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    isEqual(otherProvider) {\r\n        if (otherProvider instanceof CustomProvider) {\r\n            return (this._customProviderOptions.getToken.toString() ===\r\n                otherProvider._customProviderOptions.getToken.toString());\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Activate App Check for the given app. Can be called only once per app.\r\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\r\n * @param options - App Check initialization options\r\n * @public\r\n */\r\nfunction initializeAppCheck(app = getApp(), options) {\r\n    app = getModularInstance(app);\r\n    const provider = _getProvider(app, 'app-check');\r\n    // Ensure initializeDebugMode() is only called once.\r\n    if (!getDebugState().initialized) {\r\n        initializeDebugMode();\r\n    }\r\n    // Log a message containing the debug token when `initializeAppCheck()`\r\n    // is called in debug mode.\r\n    if (isDebugMode()) {\r\n        // Do not block initialization to get the token for the message.\r\n        void getDebugToken().then(token => \r\n        // Not using logger because I don't think we ever want this accidentally hidden.\r\n        console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\r\n    }\r\n    if (provider.isInitialized()) {\r\n        const existingInstance = provider.getImmediate();\r\n        const initialOptions = provider.getOptions();\r\n        if (initialOptions.isTokenAutoRefreshEnabled ===\r\n            options.isTokenAutoRefreshEnabled &&\r\n            initialOptions.provider.isEqual(options.provider)) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */, {\r\n                appName: app.name\r\n            });\r\n        }\r\n    }\r\n    const appCheck = provider.initialize({ options });\r\n    _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\r\n    return appCheck;\r\n}\r\n/**\r\n * Activate App Check\r\n * @param app - Firebase app to activate App Check for.\r\n * @param provider - reCAPTCHA v3 provider or\r\n * custom token provider.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. If undefined, defaults to the\r\n * value of `app.automaticDataCollectionEnabled`, which defaults to\r\n * false and can be set in the app config.\r\n */\r\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\r\n    const state = getState(app);\r\n    const newState = Object.assign(Object.assign({}, state), { activated: true });\r\n    newState.provider = provider; // Read cached token from storage if it exists and store it in memory.\r\n    newState.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\r\n        if (cachedToken && isValid(cachedToken)) {\r\n            setState(app, Object.assign(Object.assign({}, getState(app)), { token: cachedToken }));\r\n        }\r\n        return cachedToken;\r\n    });\r\n    // Use value of global `automaticDataCollectionEnabled` (which\r\n    // itself defaults to false if not specified in config) if\r\n    // `isTokenAutoRefreshEnabled` param was not provided by user.\r\n    newState.isTokenAutoRefreshEnabled =\r\n        isTokenAutoRefreshEnabled === undefined\r\n            ? app.automaticDataCollectionEnabled\r\n            : isTokenAutoRefreshEnabled;\r\n    setState(app, newState);\r\n    newState.provider.initialize(app);\r\n}\r\n/**\r\n * Set whether App Check will automatically refresh tokens as needed.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\r\n * refreshes App Check tokens as needed. This overrides any value set\r\n * during `initializeAppCheck()`.\r\n * @public\r\n */\r\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\r\n    const app = appCheckInstance.app;\r\n    const state = getState(app);\r\n    // This will exist if any product libraries have called\r\n    // `addTokenListener()`\r\n    if (state.tokenRefresher) {\r\n        if (isTokenAutoRefreshEnabled === true) {\r\n            state.tokenRefresher.start();\r\n        }\r\n        else {\r\n            state.tokenRefresher.stop();\r\n        }\r\n    }\r\n    setState(app, Object.assign(Object.assign({}, state), { isTokenAutoRefreshEnabled }));\r\n}\r\n/**\r\n * Get the current App Check token. Attaches to the most recent\r\n * in-flight request if one is present. Returns null if no token\r\n * is present and no token requests are in-flight.\r\n *\r\n * @param appCheckInstance - The App Check service instance.\r\n * @param forceRefresh - If true, will always try to fetch a fresh token.\r\n * If false, will use a cached token if found in storage.\r\n * @public\r\n */\r\nasync function getToken(appCheckInstance, forceRefresh) {\r\n    const result = await getToken$2(appCheckInstance, forceRefresh);\r\n    if (result.error) {\r\n        throw result.error;\r\n    }\r\n    return { token: result.token };\r\n}\r\n/**\r\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\r\n * pattern for public use.\r\n */\r\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError, \r\n/**\r\n * NOTE: Although an `onCompletion` callback can be provided, it will\r\n * never be called because the token stream is never-ending.\r\n * It is added only for API consistency with the observer pattern, which\r\n * we follow in JS APIs.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nonCompletion) {\r\n    let nextFn = () => { };\r\n    let errorFn = () => { };\r\n    if (onNextOrObserver.next != null) {\r\n        nextFn = onNextOrObserver.next.bind(onNextOrObserver);\r\n    }\r\n    else {\r\n        nextFn = onNextOrObserver;\r\n    }\r\n    if (onNextOrObserver.error != null) {\r\n        errorFn = onNextOrObserver.error.bind(onNextOrObserver);\r\n    }\r\n    else if (onError) {\r\n        errorFn = onError;\r\n    }\r\n    addTokenListener(appCheckInstance, \"EXTERNAL\" /* EXTERNAL */, nextFn, errorFn);\r\n    return () => removeTokenListener(appCheckInstance.app, nextFn);\r\n}\n\n/**\r\n * Firebase App Check\r\n *\r\n * @packageDocumentation\r\n */\r\nconst APP_CHECK_NAME = 'app-check';\r\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\r\nfunction registerAppCheck() {\r\n    // The public interface\r\n    _registerComponent(new Component(APP_CHECK_NAME, container => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const platformLoggerProvider = container.getProvider('platform-logger');\r\n        return factory(app, platformLoggerProvider);\r\n    }, \"PUBLIC\" /* PUBLIC */)\r\n        .setInstantiationMode(\"EXPLICIT\" /* EXPLICIT */)\r\n        /**\r\n         * Initialize app-check-internal after app-check is initialized to make AppCheck available to\r\n         * other Firebase SDKs\r\n         */\r\n        .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\r\n        container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\r\n    }));\r\n    // The internal interface used by other Firebase products\r\n    _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\r\n        const appCheck = container.getProvider('app-check').getImmediate();\r\n        return internalFactory(appCheck);\r\n    }, \"PUBLIC\" /* PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* EXPLICIT */));\r\n    registerVersion(name, version);\r\n}\r\nregisterAppCheck();\n\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };\n"]},"metadata":{},"sourceType":"module"}